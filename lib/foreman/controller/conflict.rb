module Foreman::Controller::Conflict
  def self.included(base)
      base.class_eval do
        before_filter :load_conflicts, :only => [:repair, :overwrite]
        # We need to use a different name for the filter otherwise the :only argument cannot be applied
        alias_method :find_by_name_for_compare, :find_by_name
        before_filter :find_by_name_for_compare, :only => :compare
        after_filter  :clear_collision, :except => [:compare, :update, :create]
      end
  end

  # Called when an Update or Create operation conflicted with an already present
  # network database entry and the user has responded "overwrite network entries"
  def overwrite
    load_vars_for_ajax
    forward_request_url
    if @conflicts.clear
      if @host.save
        notice "Successfully created host"
        redirect_to @host
      else
        render :action => :new
      end
    else
      error "Failed to clear conflicting network entries"
      render :action => :new
    end
  end

  # Called from the host's edit page when the "repair" button is clicked. Compares the
  # Host's network database entries with the values held in the host itself. It stores
  # the result of this comparison in the host.collision object and the session
  def compare
    return unless @host

    conflicts =  ConflictList.new @host
    if conflicts.conflict_errors.empty?
      render :partial => "conflict", :locals => {:collision => conflicts}
      session[:conflicts] = conflicts
    else
      render :text => "Network Query failed.<br>" + @host.errors.full_messages.join("<br>")
    end
  rescue => e
    logger.error  "Network Query failed: #{e.message}" + e.backtrace.join("\n")
    render :text => "Network Query failed. Please inspect the logs..."
  end

  # Called from the host's conflicts page, as generated by the "repair" button
  # Resolve the host's conflicts and adds missing data to the network databases
  # @host contains the host built from the session's collision item
  def repair
    # The return code triggers an alert in the user's browser showing the status
    # of the operation.
    if @host.managed? and @conflicts.clear and @host.regenerate @conflicts
      head 200
    else
      head 400
    end
  ensure
    session[:collision] = nil
  end

  private
  # Before_filter that is responsible for loading a ConflictList object from the session and locating
  # the host that was associated with it.
  def load_conflicts
  # Using a session variable ensures that we provide no API to directly modify network databases
    @conflicts = session[:conflicts]
    # Let us be very sure that we are operating on the same collision object
    unless ((@conflicts.check == params[:remove][:check].to_i ) rescue nil)
      error "Unable to proceed. Something went wrong with the session's conflict list."
      redirect_to hosts_path
      return false
    end
    attributes = @conflicts.host.marshal_dump
    # The host may be a new or an edited host
    @host = Host.find_or_initialize_by_id(attributes[:id], attributes)
  end

  def clear_collision
    session[:conflicts] = nil
  end

end
